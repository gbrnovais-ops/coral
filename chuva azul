<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chuva com Pingos Elípticos</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #0e293c;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <script>
        let droplets = [];
        const canvasWidth = 1100;
        const canvasHeight = 1350;
        const baseEllipseWidth = 1000;
        const baseEllipseHeight = 400;
        const rotationAngle = -350;

        // Variável para controlar a frequência de pingos (quanto menor, mais pingos)
        let dropFrequency = 10;

        function setup() {
            createCanvas(canvasWidth, canvasHeight);
            angleMode(DEGREES);
        }

        function draw() {
            background('#00aecd');
            
            // Gera novos pingos baseado na frequência ajustável
            if (frameCount % dropFrequency === 0) {
                let x = random(width);
                let y = random(height);
                droplets.push(new Droplet(x, y));
            }
            
            // Atualiza e desenha os pingos
            for(let i = 0; i < droplets.length; i++) {
                droplets[i].show();
                droplets[i].update();
                
                // Remove droplets when they completely fade out
                if(droplets[i].opacity <= 0) {
                    droplets.splice(i, 1);
                    i--;
                }
            }
        }

        function mousePressed() {
            droplets.push(new Droplet(mouseX, mouseY));
        }

        function keyPressed() {
            // Ajusta a frequência com as teclas + e -
            if (key === '+' || keyCode === UP_ARROW) {
                dropFrequency = max(1, dropFrequency - 1);
            } else if (key === '-' || keyCode === DOWN_ARROW) {
                dropFrequency = min(100, dropFrequency + 1);
            }
            return false;
        }

        class Droplet {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                
                // Calcula o fator de tamanho baseado na posição
                let distanceFromBottomLeft = dist(this.x, this.y, 0, height);
                let maxDistance = dist(width, 0, 0, height);
                this.positionFactor = map(distanceFromBottomLeft, 0, maxDistance, 1.0, 0.1);
                
                // Size variation for depth simulation
                this.sizeFactor = random(0.1, 1.0) * this.positionFactor;
                
                // Initial sizes based on perspective and position
                this.initialWidth = 30 * this.sizeFactor;
                this.width = this.initialWidth;
                this.height = this.width * (baseEllipseHeight / baseEllipseWidth);
                
                // Maximum sizes with variation based on position
                this.maxWidth = map(this.positionFactor, 0.1, 1.0, 150, 500);
                
                // Ajuste da elipse interna
                this.initialSecondWidth = this.initialWidth * random(0.6, 0.8);
                this.secondWidth = this.initialSecondWidth;
                this.secondHeight = this.secondWidth * (baseEllipseHeight / baseEllipseWidth);
                this.maxSecondWidth = this.maxWidth * random(0.7, 0.9);
                
                // Fade out properties
                this.opacity = 255;
                this.fadeStart = 0.4;
                this.fadeEnd = 0.8;
                
                // Controle de ciclo de vida
                this.lifeProgress = 0;
                this.lifeSpeed = random(0.005, 0.015);
                
                // Velocidades de expansão
                this.widthSpeed = random(1.5, 3) * (0.5 + this.positionFactor * 0.5);
                this.secondWidthSpeed = random(1.5, 2.5) * (0.5 + this.positionFactor * 0.5);
            }
            
            update() {
                // Atualiza o progresso da vida do pingo
                this.lifeProgress += this.lifeSpeed;
                
                // Expansão da elipse principal baseada no progresso da vida
                let expansionProgress = easeOutQuad(this.lifeProgress);
                this.width = this.initialWidth + (this.maxWidth - this.initialWidth) * expansionProgress;
                this.height = this.width * (baseEllipseHeight / baseEllipseWidth);
                
                // Expansão da elipse interna sincronizada com a principal
                let secondExpansionProgress = easeOutQuad(this.lifeProgress * 1.1);
                this.secondWidth = this.initialSecondWidth + (this.maxSecondWidth - this.initialSecondWidth) * secondExpansionProgress;
                this.secondHeight = this.secondWidth * (baseEllipseHeight / baseEllipseWidth);
                
                // Fade out sincronizado com a expansão
                if (this.lifeProgress > this.fadeStart) {
                    let fadeProgress = (this.lifeProgress - this.fadeStart) / (this.fadeEnd - this.fadeStart);
                    fadeProgress = constrain(fadeProgress, 0, 1);
                    
                    let fadeAmount = easeInQuad(fadeProgress);
                    this.opacity = 255 * (1 - fadeAmount);
                }
                
                // Se completou o ciclo de vida, prepara para remoção
                if (this.lifeProgress >= this.fadeEnd) {
                    this.opacity = 0;
                }
            }
            
            show() {
                noFill();
                
                // Usa a cor branca para as linhas
                stroke(255, 255, 255, this.opacity);
                
                // Espessura da linha ajustada para elipses menores
                let strokeWeightValue = map(this.opacity, 0, 255, 0.3, 1.2);
                strokeWeight(strokeWeightValue);
                
                push();
                // Move to droplet position
                translate(this.x, this.y);
                // Apply rotation
                rotate(rotationAngle);
                
                // Desenha as elipses apenas se ainda estiverem visíveis
                if (this.opacity > 0) {
                    ellipse(0, 0, this.width, this.height);
                    ellipse(0, 0, this.secondWidth, this.secondHeight);
                }
                
                pop();
            }
        }

        // Funções de easing para transições suaves
        function easeOutQuad(t) {
            return t * (2 - t);
        }

        function easeInQuad(t) {
            return t * t;
        }
    </script>
</body>
</html>
